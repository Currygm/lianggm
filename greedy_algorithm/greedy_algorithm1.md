# 最多可以参加的会议数目

## 问题

>（本题参考**力扣**，在《算法导论》中也有相同的题型）

给你一个数组`events`，其中`events[i] = [startDayi, endDayi]`，表示会议`i`开始于 `startDayi`，结束于`endDayi`。
你可以在满足`startDayi <= d <= endDayi`中的任意一天`d`参加会议`i`。在任意一天`d`中只能参加一场会议。
请你返回你可以参加的**最大**会议数目。

## 解题思路

- 本题采用了**贪心算法**的思想。整体的思路是：**先参加结束时间最早的会议**，保证先结束的会议尽可能多的参加，也留足时间参加之后的会议。
- 具体做法：首先预处理`events`：记录所有会议的**最晚结束时间**`maxDay`、对`events`中的事件按**开始时间**由早到晚排序（若开始时间相同则比较**结束时间**早晚）、用**优先队列**建立**结束时间**最小堆（结束时间早的放在最前面）。
- 之后用`i`表示日期，用`j`表示会议，遍历从`1`到`maxDay`的每一个日期。对每一个日期，从**还未遍历**的第一个会议（即开始时间**最早**的会议）开始遍历，若该会议开始时间早于该日期`i`，将该会议的**结束日期**放入优先队列。
- 将所有符合条件的会议放入优先队列之后，将结束时间早于该日期`i`，即已经**无法参加**的会议`pop`出，再从剩下的会议中挑选**结束时间最早**，即优先队列**最前面**的会议参加。
- 以此类推，直到将所有日期都遍历一遍。

## 代码

``` C++
class Solution{
private:
    int count = 0;
public:
    int maxEvents(vector<vector<int>>& events){
        int l = events.size(), maxDay = 0;
        for(int i = 0;i < l;i++){
            maxDay = max(maxDay, events[i][1]);  //记录最大的截止日期
        }
        sort(events.begin(), events.end());  //对二维vector排序，默认按元素升序，即先比较第一个元素，以此类推
        priority_queue<int, vector<int>, greater<int>> mq; //最小堆，用于升序保存各个会议的结束日期，即最小的放在最前面
        int j = 0;
        //遍历每一个日期
        for(int i = 1;i <= maxDay;i++){
            //i表示日期，j表示会议，已参加过的会议不会重复参加（i，j都只初始化一次）
            //筛选出开始时间早于i天的会议（已参加过的会议不再放入）
            while(j < l && events[j][0] <= i){
                mq.emplace(events[j][1]); //向优先队列加入新元素
                j++;
            }
            //将结束时间早于i天的过滤掉
            while(!mq.empty() && mq.top() < i){
                mq.pop();
            }
            //在符合条件的会议中挑选出结束时间最早的
            if(!mq.empty()){
                count++;
                mq.pop();
            }
        }
        return count;
    }
};
```

## 复杂度分析

- **时间复杂度**：`O((n + maxDay*n)log n)`，其中`n`表示`events`的长度，`maxDay`表示最大结束时间。对`events`快速排序的内置函数`sort`的时间复杂度为`O(nlog n)`，而**优先队列**每次进行`emplace`和`pop`的操作时的时间复杂度是`O(log k)`，`k`表示当前队列中的会议个数，在最坏的打算中`k = n`。则每个时间点进出优先队列的时间复杂度近似为`O(nlog n)`，共有`maxDay`个时间点。因此总的时间复杂度为`O((n + maxDay*n)log n)`。
- **空间复杂度**：`O(n)`，`n`为优先队列中最大的元素个数。
